We are provided with main.rs and output.txt files

main is expecting a file flag.txt in input, applies a xor based on a PRNG (with a hardcoded seed) and output the result in output.txt

main.rs is using a recent version of rand (the latest is working fine). Using an old version may compile and works, but the PRNG does not behave the same way.
Also, it is coded in rust 2018, we have to precise that to break the compatibility with rust 2015.

Based on that, we can create a Cargo.toml that will compile the code.
```
[package]
name = "guessing_game"
version = "0.1.0"
authors = ["Novice <aze@gmail.com>"]
edition = "2018"

[dependencies]
rand = "0.8.3"
```

In terms of directory structure, it still doesn't work because main.rs is not where the compiler expects it to be.

For simplicity and usage of a default path expected by the compiler, we work with the following directory structure:

```
.
| src
 \ main.rs
| Cargo.toml
| flag.txt       # our input for some tests
| out.txt.bak    # a backup of what was generated, we do not want to override it
```

The algorithm takes each letter in flag.txt in order, get the hexa code corresponding to the ascii character, and XOR it with the next hexa number of the PRNG.

In the code, we can update:
```
.map(|c| format!("{:02x}", (c as u8 ^ rng.gen::<u8>())))
```
to
```
.map(|c| format!("{:02x}", (rng.gen::<u8>())))
```

That way we get the values generated by the PRNG:
```
581140c6a0fb4a1ab2a33855897e5ebc26537402be82ef0b0c63e8940e
```

We can then xor it with the output.txt, and the following python script will give us back the characters:
```
line = '434854427b6d656d3072795f733466335f6372797074305f6634316c7d'
[chr(int(line[i:i+2], 16)) for i in range(0, len(line), n)]
```

=>
['C', 'H', 'T', 'B', '{', 'm', 'e', 'm', '0', 'r', 'y', '', 's', '4', 'f', '3', '', 'c', 'r', 'y', 'p', 't', '0', '_', 'f', '4', '1', 'l', '}']